\chapter{Интеграция системы автоматической сборки Gradle}\label{ch:----gradle}

В свете быстрого развития современных информационных технологий и повышенных требований к
эффективности программных систем, внедрение интегрированных средств автоматизации сборки является
неотъемлемым этапом в процессе разработки программного обеспечения.
В данной главе рассматривается
важная составляющая инфраструктуры разработки - интеграция системы автоматической сборки в
контексте платформы аналитики исторических данных с использованием микросервисной архитектуры.

Gradle представляет собой мощный инструмент для автоматизации процессов сборки и управления
зависимостями в проектах различной сложности.
Его гибкость и расширяемость позволяют эффективно
управлять процессом сборки как небольших приложений, так и крупных программных комплексов.
В
контексте платформы аналитики исторических данных, где требуется обеспечить высокую
производительность и надежность при обработке больших объемов информации, внедрение Gradle
представляется важным шагом для оптимизации процесса разработки и поддержки программного
обеспечения.

Данная глава направлена на анализ методов интеграции системы автоматической сборки Gradle
в существующую инфраструктуру обслуживания микросервисов платформы аналитики исторических данных.
В
частности, рассматриваются вопросы настройки Gradle для удовлетворения требований по сборке,
тестированию и развертыванию микросервисов, а также оптимизации процесса разработки и управления
зависимостями.
Предполагается, что результаты данного исследования смогут служить основой для
разработки эффективной и масштабируемой инфраструктуры сборки в рамках платформы аналитики
исторических данных, способствуя повышению производительности и надежности разрабатываемых
приложений.


\section{Обоснование выбора Gradle}\label{sec:--gradle}

В данном разделе обосновывается выбор системы автоматической сборки Gradle в качестве основного
инструмента для интеграции в инфраструктуру разработки на платформе аналитики исторических данных.

Рассматриваются основные преимущества и функциональные возможности Gradle, а также адаптация данной
системы к требованиям и особенностям разрабатываемого программного комплекса.
Рассматриваются
факторы, влияющие на принятие данного решения.

\subsection{Системы автоматизированных сборок}

Gradle — это система автоматизации сборки с открытым исходным кодом, в которой используются те же
идеи, что и в Apache Maven и Apache Ant.
Он использует предметно-ориентированный язык, основанный на
компьютерном языке Groovy или Kotlin, в отличие от Apache Maven, настройка проекта которого
использует XML.

\subsection{Системы автоматизированных сборок}

Gradle — это система автоматизации сборки с открытым исходным кодом, в которой используются те же
идеи, что и в Apache Maven и Apache Ant.
Он использует предметно-ориентированный язык, основанный на
компьютерном языке Groovy или Kotlin, в отличие от Apache Maven, настройка проекта которого
использует XML.
[1](/additionally/Литература.md\#gradle-vs-maven)

\subsection{Основные различия}\label{subsec:-2}

Существуют существенные различия в подходах к построению двух систем.
Gradle основан на модели сети
зависимостей задач, где каждая задача представляет собой исполняемый объект, выполняющий
определенные действия.
В отличие от этого, в Maven стадии проекта связаны с целями, которые
функционируют аналогично задачам в Gradle как объекты, осуществляющие выполнение работы.

\subsection{Производительность}\label{subsec:2}

Оба фреймворка обеспечивают возможность одновременного выполнения множества сборок модулей с учетом
аспектов производительности.
Gradle, в частности, обладает возможностью проведения инкрементных
сборок, так как он способен определить, какие задачи были изменены.
Кроме того, Gradle обладает
рядом выдающихся характеристик производительности, среди которых следует выделить:
\begin{enumerate}
    \item  Инкрементальная компиляция классов Java, что позволяет значительно сократить время сборки за счет
    перекомпиляции только тех классов, которые были изменены.

    \item Компиляция предотвращения для Java, предоставляющая возможность быстрого обнаружения ошибок в
    коде на этапе компиляции.

    \item API для дополнительных подзадач, что обеспечивает гибкость в настройке и расширении процесса
    сборки.

    \item Демон компилятора, который значительно ускоряет процесс компиляции за счет сохранения в памяти
    некоторых результатов предыдущих компиляций.
\end{enumerate}


На рисунке () представлен сравнительный тест производительности автоматизированной сборки
одинаковых проектов и прохождение тестов [2]


\section{Организация проекта Gradle для проекта аналитики исторических данных}\label{sec:--gradle-----}

Структурирование исходного кода и процесса сборки программных проектов играют важную роль в
обеспечении их читаемости и управляемости.
На основе накопленного опыта были выработаны оптимальные
методики, способствующие достижению этих целей.
В данном разделе рассматриваются эффективные
практики организации проектов, направленные на обеспечение их структурной ясности и удобства
сопровождения.
Также анализируются распространенные проблемы, с которыми сталкиваются разработчики,
и предлагаются методы их предотвращения.

\subsection{Разделение файлов исходного кода для определенных языков}\label{subsec:------}

Плагины для языка Gradle устанавливают определенные соглашения относительно организации и обработки
исходного кода проекта.
Например, при использовании языка программирования Java проект автоматически
компилирует
свой исходный код, расположенный в каталоге `src/main/java`.
Аналогично, плагины для других языков
следуют подобной схеме, определяя местоположение исходных файлов в соответствии с соответствующими
соглашениями.[3](/additionally/Литература.md\#plugin-java)

Некоторые компиляторы способны осуществлять кросс-компиляцию для нескольких языков, используя единый
каталог для хранения исходных файлов.
В контексте оптимизации производительности сборочных
процессов, Gradle рекомендует строго соблюдать
разделение исходных файлов по языкам программирования, что облегчает как процесс сборки, так и
обеспечивает четкость в предполагаемых структурах
проекта.
[4](/additionally/Литература.md\#organizing-gradle-project)

Представленная структура исходного кода включает в себя отдельные каталоги для файлов на Java и
Kotlin.
Файлы на Java размещаются в каталоге `src/main/java`, в то время как файлы на Kotlin
хранятся
в каталоге `src/main/kotlin`.

\begin{lstlisting}├
── build.gradle.kts
    └── src
        └── main
            ├── java
            │   └── ParserControlller.java
            └── kotlin
                └── SocketUtils.kt
\end{lstlisting}

\subsection{Тестирование}\label{subsec:}

В рамках программного проекта часто требуется проведение разнообразных видов тестирования, таких как
модульные, интеграционные, функциональные и smoke тесты.
Для эффективного управления исходным
кодом каждого типа теста рекомендуется его хранение в специально выделенных каталогах.
Практика
размещения тестового кода в отдельных каталогах положительно сказывается на удобстве сопровождения
проекта и разделении обязанностей, поскольку позволяет запускать различные типы тестов независимо
друг от друга.
Такой подход способствует повышению гибкости и эффективности процесса разработки,
облегчая выявление и устранение дефектов в приложении.
[5](/additionally/Литература.md\#test-gradle)

В частности, мы добавляем плагин соглашения, чтобы `buildSrc` разделить настройку интеграционного
теста между несколькими подпроектами:

\begin{lstlisting}
    //...
val integrationTestTask = tasks.register<Test>("integrationTest") {
    description = "Runs integration tests."
    group = "verification"
    useJUnitPlatform()

    testClassesDirs = integrationTest.output.classesDirs
    classpath = configurations[integrationTest.runtimeClasspathConfigurationName] + integrationTest.output

    shouldRunAfter(tasks.test)
}
//...
\end{lstlisting}

Применение в проекте конкретного приложения:

\begin{lstlisting}
    dependencies {
    implementation(project(":list"))
}
\end{lstlisting}

\subsection{Стандартные соглашения}\label{subsec:-}

Все встроенные плагины в Gradle придерживаются стандартных соглашений в области конфигурации в
рамках парадигмы разработки программного обеспечения.
Логика каждого плагина предоставляет
пользователям разумные значения по умолчанию и устанавливает стандарты и соглашения в определенном
контексте.

Соглашение о конфигурации (также известное как кодирование по соглашению) — это парадигма
проектирования программного обеспечения, используемая программными платформами, которая пытается
уменьшить количество решений, которые разработчик, использующий структуру, должен принимать, не
теряя при этом гибкости и не повторяясь (DRY)
принципы.
[6](/additionally/Литература.md\#programming-in-ruby-a-critical-look-at-the-pros-and-cons)

Java плагин определяет каталог src/main/java в качестве исходного каталога по умолчанию для
компиляции кода.

Выходной каталог для скомпилированного исходного кода и других артефактов
устанавливается в каталог build.

Соблюдение стандартных соглашений по умолчанию позволяет новым разработчикам проекта быстро
ориентироваться в его структуре.

\subsection{Использование `buildSrc` для инкапсуляции императивной логики}\label{subsec:-`buildsrc`----}

Для абстрагирования императивной логики в процессе сборки рекомендуется использовать
механизм `buildSrc`.
Комплексная логика сборки часто является целесообразным кандидатом для
инкапсуляции в виде пользовательской задачи или двоичного плагина.
Реализации таких пользовательских
задач и плагинов не следует размещать внутри сценариев сборки.
Использование `buildSrc` для этой
цели является предпочтительным, поскольку это позволяет избежать повторного использования кода в
различных независимых проектах.

Каталог `buildSrc` рассматривается как встроенный проект сборки.
При обнаружении этого каталога
Gradle автоматически компилирует и тестирует его содержимое, а затем включает скомпилированные
классы в путь вашего сценария сборки.
Для многопроектных сценариев сборки может быть только один
каталог `buildSrc`, который должен располагаться в корневом каталоге проекта.
Важно отдавать
предпочтение использованию плагинов сценариев, так как они обеспечивают более простое обслуживание,
рефакторинг и тестирование
кода.
[7](/additionally/Литература.md\#sharing-build-logic-between-subprojects-sample)


\section{Управление зависимостями и плагинами в Gradle}

В проекте дополнительно используется механизм централизованного управления расширением зависимостей.
Модуль позволяет указать источник версий зависимостей для каталога `libs`.
В данном случае он
указывает на файл `libs.versions.toml`,
содержащий информацию о версиях зависимостей.

\begin{lstlisting}
    dependencyResolutionManagement {
    versionCatalogs {
        create("libs") {
            from(files("configuration/libs.versions.toml"))
        }
    }
}

include("conventions")
\end{lstlisting}


В качестве основного языка для Gradle был выбран Kotlin из-за схожести синтаксиса с Java.
В данном случае, плагин kotlin-dsl включается для использования Kotlin DSL в качестве основного
языка для написания сборочных скриптов в Gradle во всем проекте.

Плагин Spring Boot Gradle обеспечивает поддержку Spring Boot в Gradle .
Он позволяет упаковывать
исполняемые jar, запускать приложения Spring Boot и использовать управление
зависимостями,
предоставляемое `spring-boot-dependencies`.
[8](/additionally/Литература.md\#справочное-руководство-по-плагину-spring-boot-gradle)

\begin{lstlisting}
    plugins {
    `kotlin-dsl`
}

dependencies {
    implementation(libs.spring.boot.gradle.plugin)
}
\end{lstlisting}


В представленном кодовом отрывке, переменная versionCatalog получает доступ к расширению
VersionCatalogsExtension и идентифицирует именованный каталог версий с названием \"libs\".

Метод api(platform(project(\":platform\"))) добавляет зависимость от платформы проекта с именем \":
platform\".
Это указывает на то, что весь проект будет использовать версии зависимостей, определенные
в данной платформе.

\begin{lstlisting}[label={lst:lstlisting}]
    val versionCatalog = extensions.getByType<VersionCatalogsExtension>().named("libs")
dependencies {
    api(platform(project(":platform")))

    versionCatalog.findLibrary("lombok").ifPresent {
        compileOnly(it)
        annotationProcessor(it)
    }
}
\end{lstlisting}



Такой подход способствует стандартизации и упрощает управление зависимостями, особенно в
масштабируемых и многоуровневых проектах.

\#\#\# Создание пользовательских задач и скриптов в Gradle

В проекте используется несколько пользовательских задач, переопределяющих стандартное поведение
Gradle.

Директива `manifest {\ldots }` определяет настройки манифеста, который содержит метаданные о проекте.
В данном контексте устанавливаются атрибуты манифеста, такие как `Implementation-Title` (название
реализации) и `Implementation-Version` (версия реализации), которые присваиваются соответственно
имени и версии проекта.

\begin{lstlisting}
    tasks.jar {
    manifest {
        attributes(
        mapOf(
        "Implementation-Title" to project.name,
        "Implementation-Version" to project.version
        )
        )
    }
}
\end{lstlisting}


\section{Оптимизация процесса сборки с использованием Gradle}\label{sec:-----gradle}

Эффективность процесса сборки играет решающую роль в производительности разработки.
Увеличение
времени сборки повышает риск прерывания рабочего процесса.
Учитывая, что сборки запускаются
многократно в течение дня, даже небольшие задержки могут существенно
накапливаться.
[9](/additionally/Литература.md\#gradle-perfomance)

\subsection{Параллельное выполнение сборки}\label{subsec:--}

Так как проект состоит более чем из одного подпроекта линейная сборка занимает значительное время
из-за не равносильности подпроектов.
Так как из-за микросервисной архитектуры подпроекты независимы
друг от друга, то они не имеют общего состояния.
В таком случае есть смысл заставить Gradle
выполнять сборку подпроектов параллельно.

Для этого в проекте используется флаг:

\begin{lstlisting}[label={lst:lstlisting2}]
    org.gradle.parallel = true
\end{lstlisting}


Результаты оптимизации представлены на рисунке:
![parallel.png](image/parallel.png)

Прирост производительности автоматизированной сборки составил 21 \%.


